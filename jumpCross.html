<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>플랫폼 점프 게임</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // 캔버스 설정
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 게임 상수 및 변수
    const gravity = 0.7;
    const scrollSpeed = 2;

    // 플레이어 객체 (시작 위치는 좌측에서 약간 떨어진 하단)
    const player = {
      x: 100,
      y: canvas.height - 150,
      width: 30,
      height: 50,
      velocityY: 0,
      jumpPower: -15,
      isJumping: false,
    };

    // 발판 배열
    let platforms = [];

    // 발판 생성 함수  
    // isDisappearing이 true이면 일정 시간 후 사라짐
    function createPlatform(x, y, width, isDisappearing = false) {
      return {
        x: x,
        y: y,
        width: width,
        height: 10,
        isDisappearing: isDisappearing,
        disappearTimer: isDisappearing ? 3000 : null, // 3000ms 후 사라짐
        elapsedTime: 0
      };
    }

    // 초기 발판 생성 (좌측부터 우측으로 이어지도록)
    function initPlatforms() {
      let x = 50;
      while (x < canvas.width * 2) {
        // 발판의 y 위치는 캔버스 하단 근처에서 약간 랜덤하게 결정
        const platformY = canvas.height - (Math.random() * 100 + 50);
        const platformWidth = 100;
        const isDisappearing = Math.random() < 0.3;  // 30% 확률
        platforms.push(createPlatform(x, platformY, platformWidth, isDisappearing));
        // 다음 발판까지의 간격 (플레이어의 점프력으로 건널 수 있는 범위)
        x += platformWidth + (Math.random() * 80 + 40);
      }
    }

    // 폭포 효과용 물 입자 배열
    let waterfallParticles = [];
    function initWaterfallParticles() {
      // 폭포 효과 영역: 캔버스 중앙 우측 약 100px 폭
      const regionXStart = canvas.width / 2 - 50;
      const regionXEnd = canvas.width / 2 + 50;
      for (let i = 0; i < 50; i++) {
        waterfallParticles.push({
          x: Math.random() * (regionXEnd - regionXStart) + regionXStart,
          y: canvas.height - Math.random() * (canvas.height / 4),
          speed: Math.random() * 1 + 1,
          alpha: Math.random() * 0.5 + 0.5
        });
      }
    }

    // 폭포 입자 업데이트: 입자가 위로 이동하여 영역 상단에 도달하면 하단으로 재배치
    function updateWaterfallParticles(deltaTime) {
      const regionYStart = canvas.height - canvas.height / 4;
      waterfallParticles.forEach(particle => {
        particle.y -= particle.speed;
        if (particle.y < regionYStart) {
          particle.y = canvas.height;
          particle.x = Math.random() * 100 + canvas.width / 2 - 50;
        }
      });
    }

    // 키 이벤트 리스너: 스페이스바나 위쪽 화살표로 점프
    document.addEventListener("keydown", function(event) {
      if ((event.code === "Space" || event.code === "ArrowUp") && !player.isJumping) {
        player.velocityY = player.jumpPower;
        player.isJumping = true;
      }
    });

    // 업데이트 및 그리기 루프
    let lastTime = performance.now();
    function update() {
      const now = performance.now();
      const deltaTime = now - lastTime;
      lastTime = now;

      // 플레이어 물리 업데이트
      player.velocityY += gravity;
      player.y += player.velocityY;

      // 캔버스 하단과 충돌 시 위치 조정
      if (player.y + player.height > canvas.height) {
        player.y = canvas.height - player.height;
        player.velocityY = 0;
        player.isJumping = false;
      }

      // 발판 위치 업데이트 (좌측으로 스크롤)
      platforms.forEach((platform, index) => {
        platform.x -= scrollSpeed;

        // 사라지는 발판: 플레이어가 발판 위에 있을 때 타이머 시작
        if (platform.isDisappearing) {
          if (
            player.x + player.width > platform.x &&
            player.x < platform.x + platform.width &&
            Math.abs((player.y + player.height) - platform.y) < 5 &&
            player.velocityY >= 0
          ) {
            platform.elapsedTime += deltaTime;
          }
          if (platform.elapsedTime > platform.disappearTimer) {
            platforms.splice(index, 1);
          }
        }
      });

      // 발판과의 충돌 체크 (플레이어가 발판에 착지)
      platforms.forEach(platform => {
        if (
          player.velocityY >= 0 &&
          player.x + player.width > platform.x &&
          player.x < platform.x + platform.width &&
          player.y + player.height <= platform.y + 10 &&
          player.y + player.height + player.velocityY >= platform.y
        ) {
          player.y = platform.y - player.height;
          player.velocityY = 0;
          player.isJumping = false;
        }
      });

      // 화면 밖(좌측)으로 완전히 벗어난 발판 제거
      while (platforms.length > 0 && platforms[0].x + platforms[0].width < 0) {
        platforms.shift();
      }

      // 우측 끝에 도달하면 새 발판 추가
      const lastPlatform = platforms[platforms.length - 1];
      if (lastPlatform && lastPlatform.x < canvas.width) {
        const newX = lastPlatform.x + lastPlatform.width + (Math.random() * 80 + 40);
        const newY = canvas.height - (Math.random() * 100 + 50);
        const newWidth = 100;
        const isDisappearing = Math.random() < 0.3;
        platforms.push(createPlatform(newX, newY, newWidth, isDisappearing));
      }

      // 폭포 입자 업데이트
      updateWaterfallParticles(deltaTime);

      draw();
      requestAnimationFrame(update);
    }

    // 그리기 함수
    function draw() {
      // 캔버스 초기화
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 배경 그리기: 좌측은 흙, 우측은 초원
      ctx.fillStyle = "#8B4513";  // 흙색
      ctx.fillRect(0, 0, canvas.width / 2, canvas.height);
      ctx.fillStyle = "#7CFC00";  // 초원색
      ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);

      // 역방향 폭포 효과 (캔버스 하단 1/4 영역)
      drawReverseWaterfall();

      // 발판 그리기  
      // – 사라지는 발판은 색상(#FF6347), 일반 발판은 색상(#0000FF)으로 구분
      platforms.forEach(platform => {
        ctx.fillStyle = platform.isDisappearing ? "#FF6347" : "#0000FF";
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
      });

      // 플레이어 그리기 (노란색)
      ctx.fillStyle = "#FFFF00";
      ctx.fillRect(player.x, player.y, player.width, player.height);
    }

    // 역방향 폭포 효과 그리기 함수
    function drawReverseWaterfall() {
      waterfallParticles.forEach(particle => {
        ctx.fillStyle = "rgba(255, 255, 255, " + particle.alpha + ")";
        ctx.fillRect(particle.x, particle.y, 2, 10);
      });
    }

    // 초기화 후 게임 시작
    initPlatforms();
    initWaterfallParticles();
    update();
  </script>
</body>
</html>
